# Beat/Meter Specification - 拍子記号の仕様

## 概要
OrbitScoreの`beat(n1 by n2)`構文における数値的制約と動作仕様を定義します。

## 現在の実装（v2.0時点）

### 構文
```js
global.beat(4 by 4)   // 4/4拍子
seq.beat(5 by 4)      // 5/4拍子（ポリメーター）
seq.beat(7 by 8)      // 7/8拍子
```

### 動作
- **分子（n1）の制限**: なし（任意の正の整数）
- **分母（n2）の制限**: なし（任意の正の数値）
- **計算**: 数学的には正しく動作するが、音楽理論的な妥当性は検証されない

### 小節長の計算式
```typescript
// 4分音符の長さ（ms）= 60000 / tempo
// 1小節の長さ（ms）= (60000 / tempo) × (numerator / denominator × 4)
```

## 将来の仕様案（厳密化 - Phase 2以降）

### 分母の制約
**許可される値**: `1, 2, 4, 8, 16, 32, 64, 128`（2のべき乗のみ）

**理由**:
- **音楽理論の枠組みを維持**: 既存の音楽家が`4/4, 120bpm`を見て「1分間に120回ビートが刻まれる速さの4分音符を基礎としてその4つ分が1小節」と即座に理解できる
- **計算の直感性**: `4/5`のような表記は音楽家にとって計算が困難
- **MIDIサポートとの整合性**: 将来的なMIDI出力時に標準的な拍子記号として正しく表現される
- **ICMC等での実績**: 4/4と5/4の位相ずれ（最小公倍数）は既に実績があり、演奏難易度も適切
- **過度な拡張の回避**: 音楽理論の枠組みを逸脱しすぎない

### 小節長の計算例

#### グローバル設定の場合

**例1: tempo(60) beat(4 by 4)**
```
4分音符の長さ = 60000ms / 60 = 1000ms
1小節の長さ = 1000ms × (4 / 4 × 4) = 1000ms × 4 = 4000ms
→ 1拍 = 1秒、1小節 = 4秒
```

**例2: tempo(60) beat(7 by 8)**
```
4分音符の長さ = 60000ms / 60 = 1000ms
1小節の長さ = 1000ms × (7 / 8 × 4) = 1000ms × 3.5 = 3500ms
→ 1拍（8分音符） = 500ms、1小節 = 3.5秒
```

**例3: tempo(120) beat(5 by 4)**
```
4分音符の長さ = 60000ms / 120 = 500ms
1小節の長さ = 500ms × (5 / 4 × 4) = 500ms × 5 = 2500ms
→ 1拍 = 500ms、1小節 = 2.5秒
```

**一般式**:
```
4分音符の長さ = 60000 / tempo (ms)
1小節の長さ = (60000 / tempo) × (numerator / denominator × 4) (ms)
```

#### シーケンス個別設定（ポリメーター）

ポリメーター機能では、各シーケンスが独立した拍子を持ち、小節線が徐々にずれていきます。

**例: グローバルとシーケンスで異なる拍子**
```js
global.tempo(60)
global.beat(4 by 4)        // グローバル: 1小節 = 4秒

var kick = init global.seq
kick.beat(4 by 4)          // キック: 1小節 = 4秒（グローバルと同期）

var snare = init global.seq
snare.beat(5 by 4)         // スネア: 1小節 = 5秒（グローバルより長い）

// 結果: kickは4秒でループ、snareは5秒でループ
// → 20秒後に再び同期（最小公倍数）
```

**計算**:
```
グローバル: 1000ms × 4 = 4000ms/bar
シーケンス: 1000ms × 5 = 5000ms/bar
→ 位相差が徐々に蓄積し、パターンが回り込む
```

## 用語の改善案

### `tempo` → `bpm`への移行

**現状**: `global.tempo(120)`
**提案**: `global.bpm(120)`

**理由**:
- BPM（Beats Per Minute）はより一般的で理解しやすい
- DAWやシーケンサーで標準的に使われる用語
- 音楽家にとって直感的

**移行計画**:
1. Phase 2で`bpm()`メソッドを追加
2. `tempo()`と`bpm()`を両方サポート（エイリアス）
3. ドキュメントでは`bpm()`を推奨表記とする
4. 後方互換性のため`tempo()`は廃止しない

## 実装の優先度

### Phase 1（現在 - v2.0）: 現状維持
- ✅ 分母の制限なし
- ✅ 数学的に正しい計算
- ✅ ポリメーター機能は動作する
- ✅ テストは基本的なケースのみ

**方針**: ポリメーター機能の動作を優先し、厳密な制約は後回し

### Phase 2（将来 - v2.1以降）: 厳密化

#### 1. パーサーでの分母検証
```typescript
// packages/engine/src/parser/parse-expression.ts
const validDenominators = [1, 2, 4, 8, 16, 32, 64, 128]
if (!validDenominators.includes(denominator)) {
  throw new Error(
    `Invalid meter denominator: ${denominator}. ` +
    `Must be a power of 2 (1, 2, 4, 8, 16, 32, 64, 128). ` +
    `This ensures compatibility with standard music notation and MIDI output.`
  )
}
```

#### 2. テストケースの追加
- 各分母での小節長計算の正確性（標準的な拍子のみ）
- エラーケース（3, 5, 6, 7, 9などの分母）
- ポリメーター機能の厳密な同期テスト
- 長時間実行での位相ずれの測定

#### 3. ドキュメント更新
- DSL仕様書に分母の制約を明記
- 標準例を追加（7/8, 9/8, 5/4など）
- MIDIサポートとの整合性を説明
- ポリメーターの数学的説明を詳細化

## テストが必要な項目

### 小節長計算の正確性（Phase 2）
- [ ] `tempo(60) beat(4 by 4)` → 4000ms
- [ ] `tempo(60) beat(3 by 4)` → 3000ms
- [ ] `tempo(60) beat(7 by 8)` → 3500ms
- [ ] `tempo(60) beat(9 by 8)` → 4500ms
- [ ] `tempo(120) beat(5 by 4)` → 2500ms
- [ ] `tempo(140) beat(7 by 4)` → ~4285.7ms

### ポリメーター機能（Phase 2）
- [ ] グローバル4/4、シーケンス5/4で位相ずれを確認
- [ ] グローバル4/4、シーケンス7/8で位相ずれを確認
- [ ] 複数シーケンス（3つ以上）で異なる拍子を同時実行
- [ ] 長時間実行（60秒以上）での同期精度

### エラーケース（Phase 2）
- [ ] `beat(4 by 3)` → エラー（非標準的な分母）
- [ ] `beat(5 by 7)` → エラー（非標準的な分母）
- [ ] `beat(8 by 9)` → エラー（非標準的な分母）
- [ ] `beat(4 by 0)` → エラー（ゼロ除算）
- [ ] `beat(4 by -4)` → エラー（負の値）
- [ ] `beat(0 by 4)` → エラー（分子がゼロ）

## 関連ドキュメント
- [DSL Specification](INSTRUCTION_ORBITSCORE_DSL.md)
- [Future Enhancements](FUTURE_ENHANCEMENTS.md)
- [Project Rules](PROJECT_RULES.md)

## 備考
- この仕様は将来的な実装のためのガイドラインです
- Phase 1では厳密な制約を課さず、柔軟性を優先します
- **Phase 2では2のべき乗の制約を導入します**:
  - 音楽理論の枠組みを維持し、既存の音楽家にとって直感的
  - MIDIサポートとの整合性を確保
  - ICMC等での実績がある4/4と5/4の位相ずれを活用
  - 過度な拡張を避け、音楽理論の枠組みを逸脱しすぎない
- 数値計算の例は概算であり、実装時に再検証が必要です

