# Beat/Meter Specification - 拍子記号の仕様

## 概要
OrbitScoreの`beat(n1 by n2)`構文における数値的制約と動作仕様を定義します。

## 現在の実装（v2.0時点）

### 構文
```js
global.beat(4 by 4)   // 4/4拍子
seq.beat(5 by 4)      // 5/4拍子（ポリメーター）
seq.beat(7 by 8)      // 7/8拍子
```

### 動作
- **分子（n1）の制限**: なし（任意の正の整数）
- **分母（n2）の制限**: なし（任意の正の数値）
- **計算**: 数学的には正しく動作するが、音楽理論的な妥当性は検証されない

### 小節長の計算式
```typescript
// 4分音符の長さ（ms）= 60000 / tempo
// 1小節の長さ（ms）= (60000 / tempo) × (numerator / denominator × 4)
```

## 将来の仕様案（厳密化 - Phase 2以降）

### 分母の制約
**許可される値**: `1, 2, 4, 8, 16, 32, 64, 128`（2のべき乗のみ）

**理由**:
- 音楽理論上の拍子記号の分母は通常2のべき乗
- 標準的な拍子: 4/4, 3/4, 6/8, 7/8, 9/8, 5/4, 7/4など
- 非標準的な拍子: 8/9, 5/7, 4/3など（これらは音楽理論上解釈が困難）
- 実装の一貫性と予測可能性を保つ

### 小節長の計算例

#### グローバル設定の場合

**例1: tempo(60) beat(4 by 4)**
```
4分音符の長さ = 60000ms / 60 = 1000ms
1小節の長さ = 1000ms × (4 / 4 × 4) = 1000ms × 4 = 4000ms
→ 1拍 = 1秒、1小節 = 4秒
```

**例2: tempo(60) beat(7 by 8)**
```
4分音符の長さ = 60000ms / 60 = 1000ms
1小節の長さ = 1000ms × (7 / 8 × 4) = 1000ms × 3.5 = 3500ms
→ 1拍（8分音符） = 500ms、1小節 = 3.5秒
```

**例3: tempo(120) beat(5 by 4)**
```
4分音符の長さ = 60000ms / 120 = 500ms
1小節の長さ = 500ms × (5 / 4 × 4) = 500ms × 5 = 2500ms
→ 1拍 = 500ms、1小節 = 2.5秒
```

**一般式**:
```
4分音符の長さ = 60000 / tempo (ms)
1小節の長さ = (60000 / tempo) × (numerator / denominator × 4) (ms)
```

#### シーケンス個別設定（ポリメーター）

ポリメーター機能では、各シーケンスが独立した拍子を持ち、小節線が徐々にずれていきます。

**例: グローバルとシーケンスで異なる拍子**
```js
global.tempo(60)
global.beat(4 by 4)        // グローバル: 1小節 = 4秒

var kick = init global.seq
kick.beat(4 by 4)          // キック: 1小節 = 4秒（グローバルと同期）

var snare = init global.seq
snare.beat(5 by 4)         // スネア: 1小節 = 5秒（グローバルより長い）

// 結果: kickは4秒でループ、snareは5秒でループ
// → 20秒後に再び同期（最小公倍数）
```

**計算**:
```
グローバル: 1000ms × 4 = 4000ms/bar
シーケンス: 1000ms × 5 = 5000ms/bar
→ 位相差が徐々に蓄積し、パターンが回り込む
```

## 用語の改善案

### `tempo` → `bpm`への移行

**現状**: `global.tempo(120)`
**提案**: `global.bpm(120)`

**理由**:
- BPM（Beats Per Minute）はより一般的で理解しやすい
- DAWやシーケンサーで標準的に使われる用語
- 音楽家にとって直感的

**移行計画**:
1. Phase 2で`bpm()`メソッドを追加
2. `tempo()`と`bpm()`を両方サポート（エイリアス）
3. ドキュメントでは`bpm()`を推奨表記とする
4. 後方互換性のため`tempo()`は廃止しない

## 実装の優先度

### Phase 1（現在 - v2.0）: 現状維持
- ✅ 分母の制限なし
- ✅ 数学的に正しい計算
- ✅ ポリメーター機能は動作する
- ✅ テストは基本的なケースのみ

**方針**: ポリメーター機能の動作を優先し、厳密な制約は後回し

### Phase 2（将来 - v2.1以降）: 厳密化

#### 1. パーサーでの分母検証
```typescript
// packages/engine/src/parser/parse-expression.ts
const validDenominators = [1, 2, 4, 8, 16, 32, 64, 128]
if (!validDenominators.includes(denominator)) {
  throw new Error(
    `Invalid meter denominator: ${denominator}. ` +
    `Must be a power of 2 (1, 2, 4, 8, 16, 32, 64, 128)`
  )
}
```

#### 2. テストケースの追加
- 各分母での小節長計算の正確性
- エラーケース（3, 5, 6, 7, 9などの分母）
- ポリメーター機能の厳密な同期テスト
- 長時間実行での位相ずれの測定

#### 3. ドキュメント更新
- DSL仕様書に分母の制約を明記
- 例を追加（7/8, 9/8, 5/4など）
- ポリメーターの数学的説明を詳細化

## テストが必要な項目

### 小節長計算の正確性（Phase 2）
- [ ] `tempo(60) beat(4 by 4)` → 4000ms
- [ ] `tempo(60) beat(3 by 4)` → 3000ms
- [ ] `tempo(60) beat(7 by 8)` → 3500ms
- [ ] `tempo(60) beat(9 by 8)` → 4500ms
- [ ] `tempo(120) beat(5 by 4)` → 2500ms
- [ ] `tempo(140) beat(7 by 4)` → ~4285.7ms

### ポリメーター機能（Phase 2）
- [ ] グローバル4/4、シーケンス5/4で位相ずれを確認
- [ ] グローバル4/4、シーケンス7/8で位相ずれを確認
- [ ] 複数シーケンス（3つ以上）で異なる拍子を同時実行
- [ ] 長時間実行（60秒以上）での同期精度

### エラーケース（Phase 2）
- [ ] `beat(4 by 3)` → エラー
- [ ] `beat(5 by 7)` → エラー
- [ ] `beat(8 by 9)` → エラー
- [ ] `beat(4 by 0)` → エラー
- [ ] `beat(4 by -4)` → エラー

## 関連ドキュメント
- [DSL Specification](INSTRUCTION_ORBITSCORE_DSL.md)
- [Future Enhancements](FUTURE_ENHANCEMENTS.md)
- [Project Rules](PROJECT_RULES.md)

## 備考
- この仕様は将来的な実装のためのガイドラインです
- Phase 1では厳密な制約を課さず、柔軟性を優先します
- Phase 2以降で段階的に厳密化を進める予定です
- 数値計算の例は概算であり、実装時に再検証が必要です

